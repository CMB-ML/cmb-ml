# make_normalization:
#   assets_out:
#     norm_file: 
#       handler: Config
#       path_template: "{root}/{dataset}/{working}{stage}/normalization.yaml"
#   assets_in:
#     cmb_map: {stage: make_sims}
#     obs_maps: {stage: make_sims}
#   dir_name: CMBNNCS_B_Extrema

# preprocess:
#   assets_out:
#     cmb_map: 
#       handler: NumpyMap
#       path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/cmb_map.npy"
#     obs_maps: 
#       handler: NumpyMap
#       path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/obs_{freq}_map.npy"
#   assets_in:
#     norm_file: {stage: make_normalization}
#     cmb_map: {stage: make_sims}
#     obs_maps: {stage: make_sims}
#     planck_deltabandpass: {stage: raw}
#   splits: &all_splits
#     - train
#     - valid
#     - test
#   dir_name: CMBNNCS_C_Preprocess
#   make_stage_log: True

make_lut:
  assets_out:
    lut: 
      handler: NumpyMap
      path_template: "{root}/{dataset}/{working}{stage}/lut.npy"
  assets_in:
    cmb_map: {stage: make_sims}
    obs_maps: {stage: make_sims}
  dir_name: PatchNN_0_LUT

snip_patches_cfg:
  assets_out:
    all_ids:
      handler: Config
      path_template: "{root}/{dataset}/{working}{stage}/{split}/all_patches.yaml"
    patch_id:
      handler: PlainText
      path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/patch_id.txt"
  assets_in:
    planck_deltabandpass: {stage: raw}
    mask: {stage: make_mask}
  dir_name: PatchNN_00_Patches
  splits:
    - train
    - valid

test_patch_dist:
  assets_in:
    patch_id: {stage: snip_patches_cfg}
    # cmb_map: {stage: make_sims}
    # obs_maps: {stage: make_sims}
    # planck_deltabandpass: {stage: raw}
  splits:
    - train
  dir_name: PatchNN_0_Test_Patch
  make_stage_log: False

test_patch:
  assets_in:
    patch_id: {stage: snip_patches_cfg}
    cmb_map: {stage: make_sims}
    obs_maps: {stage: make_sims}
    planck_deltabandpass: {stage: raw}
  splits:
    - train
  dir_name: PatchNN_0_Test_Patch
  make_stage_log: False
  override_n_sims: ${n_show_cap}

train:
  assets_out:
    model: 
      handler: PyTorchModel
      path_template: "{root}/{dataset}/{working}{stage}/model_{epoch}.pth"
  assets_in:
    # norm_file: {stage: make_normalization}
    lut: {stage: make_lut}
    model: {stage: train}
    cmb_map: {stage: make_sims}
    obs_maps: {stage: make_sims}
    patch_dict: {stage: snip_patches_cfg, orig_name: all_ids}
  splits:
    - train
  dir_name: PatchNN_E_Model
  make_stage_log: True

predict: &final_inference
  assets_out:
    cmb_map: 
      # handler: NumpyMap
      handler: HealpyMap
      # path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/cmb_map_pred_{epoch}.npy"
      path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/cmb_map_pred_{epoch}.fits"
  assets_in:
    lut: {stage: make_lut}
    model: {stage: train}
    obs_maps: {stage: make_sims}
#     norm_file: {stage: make_normalization}
  splits:
    - ${splits.run_inference_on}
  epochs: ${use_epochs}
  dir_name: PatchNN_E_Predict
  make_stage_log: True

# postprocess: &final_inference
#   assets_out:
#     cmb_map: 
#       handler: HealpyMap
#       path_template: "{root}/{dataset}/{working}{stage}/{split}/{sim}/cmb_map_post_{epoch}.fits"
#   assets_in:
#     cmb_map: {stage: predict}
#   splits:
#     - ${splits.run_inference_on}
#   epochs: ${use_epochs}
#   dir_name: CMBNNCS_F_Postprocess
#   make_stage_log: True

final_infer: *final_inference  # Used so that analysis code can find a consistent name
